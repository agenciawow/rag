# streamlit_rag_app_producao.py

import streamlit as st
import json
import hashlib
import logging
from datetime import datetime
from pathlib import Path
import time
from typing import Dict, Any, Optional

# Importa a vers√£o de produ√ß√£o
from buscador_conversacional_producao import ProductionConversationalRAG, health_check

# Configura√ß√£o da p√°gina
st.set_page_config(
    page_title="RAG Conversacional - Produ√ß√£o",
    page_icon="üöÄ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Configura√ß√£o de logging para Streamlit
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - Streamlit - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

class StreamlitUserManager:
    """Gerenciador de usu√°rios para Streamlit (vers√£o produ√ß√£o)"""
    
    def __init__(self, users_file="production_users.json"):
        self.users_file = Path(users_file)
        self.users = self.load_users()
        self._create_default_users()
    
    def _create_default_users(self):
        """Cria usu√°rios padr√£o se n√£o existirem"""
        default_users = {
            "admin": {
                "password_hash": self.hash_password("admin123"),
                "name": "Administrador",
                "role": "Admin",
                "organization": "Sistema",
                "permissions": ["extract", "stats", "clear_all"]
            },
            "pesquisador": {
                "password_hash": self.hash_password("pesquisa123"),
                "name": "Dr. Pesquisador",
                "role": "Pesquisador",
                "organization": "Universidade",
                "permissions": ["extract", "stats"]
            },
            "demo": {
                "password_hash": self.hash_password("demo123"),
                "name": "Usu√°rio Demo",
                "role": "Demonstra√ß√£o",
                "organization": "Demo",
                "permissions": []
            }
        }
        
        # Adiciona usu√°rios que n√£o existem
        updated = False
        for username, user_data in default_users.items():
            if username not in self.users:
                self.users[username] = user_data
                updated = True
        
        if updated:
            self.save_users()
    
    def load_users(self) -> Dict:
        """Carrega usu√°rios do arquivo"""
        if self.users_file.exists():
            try:
                with open(self.users_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
            except Exception as e:
                logger.error(f"Erro ao carregar usu√°rios: {e}")
                return {}
        return {}
    
    def save_users(self):
        """Salva usu√°rios no arquivo"""
        try:
            with open(self.users_file, 'w', encoding='utf-8') as f:
                json.dump(self.users, f, indent=2, ensure_ascii=False)
        except Exception as e:
            logger.error(f"Erro ao salvar usu√°rios: {e}")
    
    def hash_password(self, password: str) -> str:
        """Hash da senha com salt"""
        salt = "streamlit_rag_production_2025"
        return hashlib.sha256((password + salt).encode()).hexdigest()
    
    def authenticate(self, username: str, password: str) -> bool:
        """Autentica usu√°rio"""
        if username in self.users:
            return self.users[username]["password_hash"] == self.hash_password(password)
        return False
    
    def get_user_info(self, username: str) -> Dict:
        """Pega informa√ß√µes do usu√°rio"""
        return self.users.get(username, {})
    
    def has_permission(self, username: str, permission: str) -> bool:
        """Verifica se usu√°rio tem permiss√£o espec√≠fica"""
        user = self.users.get(username, {})
        return permission in user.get("permissions", [])

class ProductionStreamlitRAG:
    """RAG de produ√ß√£o adaptado para Streamlit com cache e otimiza√ß√µes"""
    
    def __init__(self, user_id: str):
        self.user_id = user_id
        self.user_dir = Path(f"production_users/{user_id}")
        self.user_dir.mkdir(parents=True, exist_ok=True)
        self.memory_file = self.user_dir / "chat_history.json"
        self.stats_file = self.user_dir / "user_stats.json"
        
        # Inicializa RAG de produ√ß√£o (com cache global no Streamlit)
        self._initialize_rag()
        
        # Carrega hist√≥rico e estat√≠sticas do usu√°rio
        self.load_user_data()
    
    @st.cache_resource
    def _get_global_rag_instance():
        """Inst√¢ncia global do RAG (cache do Streamlit)"""
        try:
            logger.info("Inicializando inst√¢ncia global RAG de produ√ß√£o...")
            return ProductionConversationalRAG()
        except Exception as e:
            logger.error(f"Erro ao inicializar RAG: {e}")
            st.error(f"‚ùå Erro na inicializa√ß√£o: {e}")
            return None
    
    def _initialize_rag(self):
        """Inicializa RAG usando cache global"""
        if "rag_instance" not in st.session_state:
            st.session_state.rag_instance = self._get_global_rag_instance()
        
        if st.session_state.rag_instance is None:
            st.error("‚ùå Sistema RAG n√£o inicializado corretamente")
            st.stop()
    
    def load_user_data(self):
        """Carrega dados espec√≠ficos do usu√°rio"""
        # Carrega hist√≥rico
        if self.memory_file.exists():
            try:
                with open(self.memory_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    # Define hist√≥rico espec√≠fico do usu√°rio no RAG
                    st.session_state.rag_instance.chat_history = data.get("chat_history", [])
            except Exception as e:
                logger.warning(f"Erro ao carregar hist√≥rico do usu√°rio {self.user_id}: {e}")
                st.session_state.rag_instance.chat_history = []
        else:
            st.session_state.rag_instance.chat_history = []
        
        # Carrega estat√≠sticas
        self.user_stats = self._load_user_stats()
    
    def _load_user_stats(self) -> Dict:
        """Carrega estat√≠sticas do usu√°rio"""
        if self.stats_file.exists():
            try:
                with open(self.stats_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
            except:
                pass
        
        return {
            "total_questions": 0,
            "successful_answers": 0,
            "extraction_count": 0,
            "first_login": datetime.now().isoformat(),
            "last_activity": datetime.now().isoformat()
        }
    
    def _save_user_stats(self):
        """Salva estat√≠sticas do usu√°rio"""
        try:
            self.user_stats["last_activity"] = datetime.now().isoformat()
            with open(self.stats_file, 'w', encoding='utf-8') as f:
                json.dump(self.user_stats, f, indent=2, ensure_ascii=False)
        except Exception as e:
            logger.error(f"Erro ao salvar estat√≠sticas: {e}")
    
    def save_user_history(self):
        """Salva hist√≥rico do usu√°rio"""
        try:
            memory_data = {
                "user_id": self.user_id,
                "last_updated": datetime.now().isoformat(),
                "total_messages": len(st.session_state.rag_instance.chat_history),
                "chat_history": st.session_state.rag_instance.chat_history
            }
            
            with open(self.memory_file, 'w', encoding='utf-8') as f:
                json.dump(memory_data, f, indent=2, ensure_ascii=False)
            
            self._save_user_stats()
        except Exception as e:
            logger.error(f"Erro ao salvar hist√≥rico: {e}")
            st.error(f"Erro ao salvar dados: {e}")
    
    def ask(self, question: str) -> str:
        """Faz pergunta usando RAG de produ√ß√£o e salva automaticamente"""
        try:
            self.user_stats["total_questions"] += 1
            
            # Usa o m√©todo ask da vers√£o de produ√ß√£o
            response = st.session_state.rag_instance.ask(question)
            
            if "erro" not in response.lower() and "desculpe" not in response.lower():
                self.user_stats["successful_answers"] += 1
            
            self.save_user_history()
            return response
            
        except Exception as e:
            logger.error(f"Erro na pergunta do usu√°rio {self.user_id}: {e}")
            return f"‚ùå Erro ao processar pergunta: {e}"
    
    def clear_history(self):
        """Limpa hist√≥rico do usu√°rio"""
        st.session_state.rag_instance.clear_history()
        self.save_user_history()
        logger.info(f"Hist√≥rico limpo para usu√°rio {self.user_id}")
    
    def get_history(self):
        """Retorna hist√≥rico atual"""
        return st.session_state.rag_instance.chat_history
    
    def extract_data(self, template: dict, document_filter: Optional[str] = None):
        """Extrai dados estruturados usando RAG de produ√ß√£o"""
        try:
            self.user_stats["extraction_count"] += 1
            self._save_user_stats()
            
            return st.session_state.rag_instance.extract_structured_data(template, document_filter)
        except Exception as e:
            logger.error(f"Erro na extra√ß√£o para usu√°rio {self.user_id}: {e}")
            return {
                "status": "error",
                "message": f"Erro na extra√ß√£o: {e}"
            }
    
    def get_system_stats(self):
        """Obt√©m estat√≠sticas do sistema"""
        try:
            return st.session_state.rag_instance.get_system_stats()
        except Exception as e:
            logger.error(f"Erro ao obter estat√≠sticas: {e}")
            return {"error": str(e)}
    
    def get_user_stats(self):
        """Retorna estat√≠sticas do usu√°rio"""
        return self.user_stats.copy()

def login_page():
    """P√°gina de login com informa√ß√µes da vers√£o de produ√ß√£o"""
    st.title("üöÄ Login - Sistema RAG Conversacional (Produ√ß√£o)")
    
    # Health check do sistema
    with st.spinner("Verificando sistema..."):
        try:
            health_status = health_check()
            if health_status["status"] == "healthy":
                st.success("‚úÖ Sistema operacional")
            elif health_status["status"] == "degraded":
                st.warning("‚ö†Ô∏è Sistema com degrada√ß√£o")
            else:
                st.error("‚ùå Sistema com problemas")
                st.json(health_status)
        except Exception as e:
            st.error(f"‚ùå Erro no health check: {e}")
    
    col1, col2, col3 = st.columns([1, 2, 1])
    
    with col2:
        st.markdown("### üîê Acesso ao Sistema")
        
        # Credentials de demonstra√ß√£o
        with st.expander("üëÄ Credenciais de Demonstra√ß√£o"):
            st.markdown("""
            **Usu√°rios dispon√≠veis:**
            - **admin** / admin123 (Administrador completo)
            - **pesquisador** / pesquisa123 (Pesquisador)
            - **demo** / demo123 (Demonstra√ß√£o b√°sica)
            """)
        
        with st.form("login_form"):
            username = st.text_input("üë§ Usu√°rio", placeholder="Digite seu usu√°rio")
            password = st.text_input("üîí Senha", type="password", placeholder="Digite sua senha")
            login_button = st.form_submit_button("üöÄ Entrar", use_container_width=True)
        
        if login_button:
            if username and password:
                user_manager = StreamlitUserManager()
                
                if user_manager.authenticate(username, password):
                    # Login bem-sucedido
                    st.session_state.authenticated = True
                    st.session_state.username = username
                    st.session_state.user_info = user_manager.get_user_info(username)
                    st.session_state.user_manager = user_manager
                    
                    logger.info(f"Login bem-sucedido: {username}")
                    st.success(f"‚úÖ Bem-vindo, {st.session_state.user_info.get('name', username)}!")
                    time.sleep(1)
                    st.rerun()
                else:
                    st.error("‚ùå Usu√°rio ou senha incorretos!")
                    logger.warning(f"Tentativa de login falhada: {username}")
            else:
                st.warning("‚ö†Ô∏è Preencha todos os campos!")
        
        # Informa√ß√µes do sistema de produ√ß√£o
        st.markdown("---")
        st.markdown("### üìã Sistema de Produ√ß√£o")
        st.info("""
        **üöÄ Recursos de Produ√ß√£o Ativos:**
        - üß† Query transformer inteligente com cache
        - üîÑ Fallbacks autom√°ticos robustos
        - üìä Logging estruturado e monitoramento
        - ‚ö° Otimiza√ß√µes de performance
        - üõ°Ô∏è Valida√ß√£o de ambiente e seguran√ßa
        - üíæ Mem√≥ria persistente por usu√°rio
        - üìà Estat√≠sticas detalhadas de uso
        """)

def sidebar_user_info():
    """Sidebar otimizada com informa√ß√µes do usu√°rio e sistema"""
    with st.sidebar:
        st.markdown("### üë§ Usu√°rio Logado")
        user_info = st.session_state.get('user_info', {})
        
        st.markdown(f"**Nome:** {user_info.get('name', 'N/A')}")
        st.markdown(f"**Perfil:** {user_info.get('role', 'N/A')}")
        st.markdown(f"**Organiza√ß√£o:** {user_info.get('organization', 'N/A')}")
        
        # Estat√≠sticas do usu√°rio
        if 'user_rag' in st.session_state:
            try:
                user_stats = st.session_state.user_rag.get_user_stats()
                st.markdown("### üìä Suas Estat√≠sticas")
                st.metric("Perguntas", user_stats.get("total_questions", 0))
                st.metric("Respostas bem-sucedidas", user_stats.get("successful_answers", 0))
                st.metric("Extra√ß√µes realizadas", user_stats.get("extraction_count", 0))
                
                # Taxa de sucesso
                if user_stats.get("total_questions", 0) > 0:
                    success_rate = (user_stats.get("successful_answers", 0) / user_stats.get("total_questions", 1)) * 100
                    st.metric("Taxa de sucesso", f"{success_rate:.1f}%")
            except Exception as e:
                logger.error(f"Erro ao exibir estat√≠sticas: {e}")
        
        st.markdown("---")
        
        # Bot√µes de a√ß√£o com permiss√µes
        if st.button("üßπ Limpar Conversa", use_container_width=True):
            if 'user_rag' in st.session_state:
                st.session_state.user_rag.clear_history()
                st.success("‚úÖ Conversa limpa!")
                st.rerun()
        
        # Extra√ß√£o de dados (com permiss√£o)
        user_manager = st.session_state.get('user_manager')
        if user_manager and user_manager.has_permission(st.session_state.username, "extract"):
            if st.button("üìä Extrair Dados", use_container_width=True):
                st.session_state.show_extraction = True
        
        # Estat√≠sticas do sistema (com permiss√£o)
        if user_manager and user_manager.has_permission(st.session_state.username, "stats"):
            if st.button("üìà Estat√≠sticas Sistema", use_container_width=True):
                st.session_state.show_system_stats = True
        
        if st.button("üö™ Logout", use_container_width=True):
            # Log da sa√≠da
            logger.info(f"Logout: {st.session_state.get('username', 'unknown')}")
            
            # Limpa sess√£o
            for key in list(st.session_state.keys()):
                del st.session_state[key]
            st.rerun()
        
        st.markdown("---")
        st.markdown("### üìö Recursos Dispon√≠veis")
        st.markdown("""
        **üîç Consultas Inteligentes:**
        - Perguntas naturais contextuais
        - Refer√™ncias a conversas anteriores
        - An√°lise de tabelas e figuras
        - Seguimento autom√°tico de t√≥picos
        
        **üöÄ Otimiza√ß√µes de Produ√ß√£o:**
        - Cache de transforma√ß√µes
        - Fallbacks autom√°ticos
        - Verifica√ß√£o de relev√¢ncia
        - Logging detalhado
        """)

def system_stats_modal():
    """Modal para exibir estat√≠sticas do sistema"""
    if st.session_state.get('show_system_stats', False):
        st.markdown("### üìà Estat√≠sticas do Sistema")
        
        if 'user_rag' in st.session_state:
            with st.spinner("Coletando estat√≠sticas..."):
                try:
                    stats = st.session_state.user_rag.get_system_stats()
                    
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        st.markdown("#### üóÉÔ∏è Sistema")
                        st.json({
                            "Status": stats.get("system_health", "unknown"),
                            "Database": stats.get("database_status", "unknown"),
                            "Hist√≥rico atual": stats.get("chat_history_length", 0)
                        })
                    
                    with col2:
                        st.markdown("#### üß† Query Transformer")
                        transformer_stats = stats.get("transformer_stats", {})
                        st.json({
                            "Cache size": transformer_stats.get("cache_size", 0),
                            "Cache hits": transformer_stats.get("cache_hits", 0),
                            "LLM calls": transformer_stats.get("llm_calls", 0)
                        })
                    
                    # Health check atual
                    st.markdown("#### üè• Health Check")
                    try:
                        health_status = health_check()
                        
                        status_color = {
                            "healthy": "üü¢",
                            "degraded": "üü°", 
                            "error": "üî¥"
                        }.get(health_status["status"], "‚ö™")
                        
                        st.markdown(f"{status_color} **Status:** {health_status['status']}")
                        st.json(health_status)
                        
                    except Exception as e:
                        st.error(f"Erro no health check: {e}")
                        
                except Exception as e:
                    st.error(f"Erro ao coletar estat√≠sticas: {e}")
        
        if st.button("‚ùå Fechar Estat√≠sticas", use_container_width=True):
            st.session_state.show_system_stats = False
            st.rerun()

def extraction_modal():
    """Modal para extra√ß√£o de dados com templates otimizados"""
    if st.session_state.get('show_extraction', False):
        st.markdown("### üìä Extra√ß√£o de Dados Estruturados")
        
        # Templates espec√≠ficos para documentos acad√™micos
        templates = {
            "üìÑ Informa√ß√µes do Paper": {
                "title": "",
                "authors": [],
                "abstract": "",
                "year": "",
                "venue": "",
                "keywords": []
            },
            "üî¨ Metodologia T√©cnica": {
                "approach_name": "",
                "algorithms": [],
                "datasets_used": [],
                "evaluation_metrics": [],
                "baseline_comparisons": []
            },
            "üìä Resultados e Performance": {
                "best_performance": "",
                "performance_metrics": {},
                "tables_referenced": [],
                "key_findings": [],
                "limitations": []
            },
            "üèóÔ∏è Arquitetura Zep/Graphiti": {
                "architecture_components": [],
                "temporal_features": [],
                "invalidation_mechanisms": [],
                "memory_management": "",
                "performance_optimizations": []
            },
            "üîß Implementa√ß√£o": {
                "programming_languages": [],
                "frameworks_used": [],
                "hardware_requirements": "",
                "software_dependencies": [],
                "installation_steps": []
            },
            "üéõÔ∏è Personalizado": {}
        }
        
        template_choice = st.selectbox("üìã Escolha um template:", list(templates.keys()))
        
        # Filtro por documento (se dispon√≠vel)
        doc_filter = st.text_input(
            "üìÅ Filtrar por documento (opcional):", 
            placeholder="Ex: 2501_13956",
            help="Deixe vazio para buscar em todos os documentos"
        )
        
        if template_choice == "üéõÔ∏è Personalizado":
            custom_template = st.text_area(
                "Template JSON personalizado:",
                value='{\n  "campo1": "",\n  "campo2": [],\n  "campo3": {}\n}',
                height=200,
                help="Use arrays [] para listas e {} para objetos"
            )
            try:
                template = json.loads(custom_template)
            except json.JSONDecodeError as e:
                st.error(f"‚ùå JSON inv√°lido: {e}")
                return
        else:
            template = templates[template_choice]
            st.markdown("**Template selecionado:**")
            st.json(template)
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            if st.button("üîç Extrair Dados", use_container_width=True):
                if 'user_rag' in st.session_state:
                    with st.spinner("Extraindo dados usando IA..."):
                        try:
                            result = st.session_state.user_rag.extract_data(
                                template, 
                                doc_filter if doc_filter.strip() else None
                            )
                            
                            if result.get("status") == "success":
                                st.success("‚úÖ Dados extra√≠dos com sucesso!")
                                
                                # Exibe dados extra√≠dos
                                st.markdown("#### üìã Dados Extra√≠dos:")
                                st.json(result["data"])
                                
                                # Informa√ß√µes adicionais
                                st.info(f"üìä P√°ginas analisadas: {result.get('pages_analyzed', 'N/A')}")
                                
                                # Op√ß√µes de download
                                json_str = json.dumps(result["data"], indent=2, ensure_ascii=False)
                                timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                                filename = f"extracao_{template_choice.replace('üéõÔ∏è ', '').replace('üìÑ ', '').replace(' ', '_')}_{timestamp}.json"
                                
                                st.download_button(
                                    "üíæ Baixar JSON",
                                    json_str,
                                    file_name=filename,
                                    mime="application/json",
                                    use_container_width=True
                                )
                                
                            else:
                                st.error(f"‚ùå Erro na extra√ß√£o: {result.get('message', 'Erro desconhecido')}")
                                
                        except Exception as e:
                            st.error(f"‚ùå Erro durante extra√ß√£o: {e}")
                            logger.error(f"Erro na extra√ß√£o: {e}")
        
        with col2:
            if st.button("üîÑ Limpar Template", use_container_width=True):
                st.rerun()
        
        with col3:
            if st.button("‚ùå Fechar", use_container_width=True):
                st.session_state.show_extraction = False
                st.rerun()

def chat_interface():
    """Interface principal de chat otimizada para produ√ß√£o"""
    st.title("üöÄ RAG Conversacional - Produ√ß√£o")
    
    # Badge de status de produ√ß√£o
    col1, col2, col3 = st.columns([2, 1, 1])
    with col2:
        st.markdown('<div style="text-align: center;"><span style="background-color: #28a745; color: white; padding: 4px 12px; border-radius: 12px; font-size: 12px;">üöÄ PRODU√á√ÉO</span></div>', unsafe_allow_html=True)
    
    # Inicializa RAG do usu√°rio se n√£o existir
    if 'user_rag' not in st.session_state:
        with st.spinner("Inicializando sistema RAG de produ√ß√£o..."):
            try:
                st.session_state.user_rag = ProductionStreamlitRAG(st.session_state.username)
                st.success("‚úÖ Sistema inicializado com sucesso!")
            except Exception as e:
                st.error(f"‚ùå Erro na inicializa√ß√£o: {e}")
                logger.error(f"Erro ao inicializar RAG para {st.session_state.username}: {e}")
                st.stop()
    
    # Modals
    extraction_modal()
    system_stats_modal()
    
    # Container para mensagens
    chat_container = st.container()
    
    # Exibe hist√≥rico da conversa
    with chat_container:
        history = st.session_state.user_rag.get_history()
        
        if history:
            for i, message in enumerate(history):
                if message["role"] == "user":
                    with st.chat_message("user"):
                        st.write(message["content"])
                else:
                    with st.chat_message("assistant"):
                        st.write(message["content"])
        else:
            # Mensagem de boas-vindas personalizada
            user_name = st.session_state.user_info.get('name', 'usu√°rio')
            welcome_msg = f"""
            üëã Ol√°, **{user_name}**! Bem-vindo ao sistema RAG de produ√ß√£o.
            
            üöÄ **Recursos dispon√≠veis:**
            - Perguntas contextuais inteligentes
            - Mem√≥ria de conversas anteriores  
            - An√°lise de documentos acad√™micos
            - Extra√ß√£o de dados estruturados
            
            üí° **Exemplos de perguntas:**
            - "O que √© o Zep Graphiti?"
            - "Explique a arquitetura temporal"
            - "Quais s√£o os resultados de performance?"
            - "Como funciona a invalida√ß√£o de mem√≥ria?"
            
            Fa√ßa sua primeira pergunta!
            """
            st.markdown(welcome_msg)
    
    # Input para nova mensagem
    if prompt := st.chat_input("Digite sua pergunta..."):
        # Mostra pergunta do usu√°rio
        with st.chat_message("user"):
            st.write(prompt)
        
        # Gera resposta usando sistema de produ√ß√£o
        with st.chat_message("assistant"):
            with st.spinner("üß† Processando com IA..."):
                try:
                    start_time = time.time()
                    response = st.session_state.user_rag.ask(prompt)
                    processing_time = time.time() - start_time
                    
                    st.write(response)
                    
                    # Mostra tempo de processamento para admin
                    if st.session_state.user_info.get('role') == 'Admin':
                        st.caption(f"‚è±Ô∏è Processado em {processing_time:.2f}s")
                        
                except Exception as e:
                    error_msg = f"‚ùå Erro ao processar pergunta: {e}"
                    st.error(error_msg)
                    logger.error(f"Erro no chat para {st.session_state.username}: {e}")
                    
                    # Fallback para admin
                    if st.session_state.user_info.get('role') == 'Admin':
                        st.markdown("**Debug Info:**")
                        st.code(str(e))

def main():
    """Fun√ß√£o principal da aplica√ß√£o de produ√ß√£o"""
    # CSS personalizado para melhor apar√™ncia
    st.markdown("""
    <style>
    .stApp > header {
        background-color: transparent;
    }
    .stApp {
        margin-top: -80px;
    }
    </style>
    """, unsafe_allow_html=True)
    
    # Inicializa estado da sess√£o
    if 'authenticated' not in st.session_state:
        st.session_state.authenticated = False
    
    # Verifica autentica√ß√£o
    if not st.session_state.authenticated:
        login_page()
    else:
        # Interface principal de produ√ß√£o
        sidebar_user_info()
        chat_interface()

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        logger.critical(f"Erro cr√≠tico na aplica√ß√£o: {e}")
        st.error(f"‚ùå Erro cr√≠tico: {e}")
        st.markdown("**Verifique:**")
        st.markdown("1. Vari√°veis de ambiente configuradas")
        st.markdown("2. Conex√£o com Astra DB")
        st.markdown("3. Documentos indexados corretamente")
        st.markdown("4. Depend√™ncias instaladas")